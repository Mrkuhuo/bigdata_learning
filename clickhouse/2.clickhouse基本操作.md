### 1. 在ClickHouse中创建表

像大多数数据库管理系统一样，ClickHouse在逻辑上将表分组到数据库中。使用CREATE DATABASE命令在ClickHouse中创建一个新数据库:

```
CREATE DATABASE IF NOT EXISTS helloworld
```

类似地，使用CREATE TABLE定义一个新表。(如果不指定数据库名称，则表将位于默认数据库中。)下面的表名为helloworld数据库中的my_first_table:

```
CREATE TABLE helloworld.my_first_table
(
user_id UInt32,
message String,
timestamp DateTime,
metric Float32
)
ENGINE = MergeTree()
PRIMARY KEY (user_id, timestamp)
```

在上面的例子中，my_first_table是一个合并树表，有四列:

* user_id: 32位无符号整数
* message: String数据类型，替换其他数据库系统中的VARCHAR、BLOB、CLOB等类型
* timestamp:一个DateTime值，表示时间上的某一时刻
* Metric: 32位浮点数

**请注意**
表引擎可以用来确定:
* 如何以及在哪里存储数据
* 支持哪些查询
* 是否复制数据
有许多引擎可供选择，但对于单节点ClickHouse服务器上的简单表，可能会选择MergeTree。

#### 主键简介

在继续之前，了解主键在ClickHouse中的工作原理是很重要的(主键的实现可能看起来出乎意料!):

* ClickHouse中的主键对于表中的每一行都不是唯一的

ClickHouse表的主键决定数据写入磁盘时的排序方式。每8192行或10MB数据(称为索引粒度)在主键索引文件中创建一个条目。这种粒度概念创建了一个可以轻松装入内存的稀疏索引，颗粒表示SELECT查询期间处理的列数据的最小数量的条。

主键可以使用primary key参数定义。如果定义的表没有指定PRIMARY KEY，则该键将成为ORDER BY子句中指定的元组。如果同时指定了PRIMARY KEY和ORDER BY，则主键必须是排序顺序的子集。

主键也是排序键，它是(user_id, timestamp)的元组。因此，存储在每个列文件中的数据将按user_id排序，然后是时间戳。

### 2. 插入数据到ClickHouse

您可以对ClickHouse使用熟悉的INSERT INTO TABLE命令，但重要的是要理解对合并树表的每次插入都会导致在存储中创建一个部件。即使是一个简单的例子，让我们一次插入多行:

```
INSERT INTO helloworld.my_first_table (user_id, message, timestamp, metric) VALUES
(101, 'Hello, ClickHouse!',                                 now(),       -1.0    ),
(102, 'Insert a lot of rows per batch',                     yesterday(), 1.41421 ),
(102, 'Sort your data based on your commonly-used queries', today(),     2.718   ),
(101, 'Granules are the smallest chunks of data read',      now() + 5,   3.14159 )
```

注意，时间戳列是使用各种Date和DateTime函数填充的。ClickHouse有数百个有用的函数，您可以在函数部分查看。

让我们验证一下它是否工作-您应该会看到插入的四行数据。

```
SELECT * FROM helloworld.my_first_table
```

**每批插入大量的行——一次插入数万甚至数百万行。别担心- ClickHouse可以轻松处理这种类型的音量!**

**如果您不能一次插入很多行，并且您使用的是HTTP客户端，则使用async_insert设置，该设置在将较小的插入插入到表之前对它们进行批量处理。**

### 3. 在ClickHouse查询

ClickHouse是一个SQL数据库，您可以通过编写您已经熟悉的相同类型的SELECT查询来查询数据。例如:

```
SELECT *
FROM helloworld.my_first_table
ORDER BY timestamp
```

**注意，返回的响应是一个很好的表格格式:**

```
┌─user_id─┬─message────────────────────────────────────────────┬───────────timestamp─┬──metric─┐
│     102 │ Insert a lot of rows per batch                     │ 2022-03-21 00:00:00 │ 1.41421 │
│     102 │ Sort your data based on your commonly-used queries │ 2022-03-22 00:00:00 │   2.718 │
│     101 │ Hello, ClickHouse!                                 │ 2022-03-22 14:04:09 │      -1 │
│     101 │ Granules are the smallest chunks of data read      │ 2022-03-22 14:04:14 │ 3.14159 │
└─────────┴────────────────────────────────────────────────────┴─────────────────────┴─────────┘

4 rows in set. Elapsed: 0.008 sec.
```

添加一个FORMAT子句来指定ClickHouse支持的多种输出格式:

```
SELECT *
FROM helloworld.my_first_table
ORDER BY timestamp
FORMAT TabSeparated
```

在上面的查询中，输出以制表符分隔返回:

```
Query id: 3604df1c-acfd-4117-9c56-f86c69721121

102 Insert a lot of rows per batch  2022-03-21 00:00:00 1.41421
102 Sort your data based on your commonly-used queries  2022-03-22 00:00:00 2.718
101 Hello, ClickHouse!  2022-03-22 14:04:09 -1
101 Granules are the smallest chunks of data read   2022-03-22 14:04:14 3.14159

4 rows in set. Elapsed: 0.005 sec.
```

请注意
ClickHouse支持超过70种输入和输出格式，因此在数千个函数和所有数据格式之间，您可以使用ClickHouse执行一些令人印象深刻的快速的类似etl的数据转换。事实上，你甚至不需要一个ClickHouse服务器来转换数据——你可以使用ClickHouse -local工具。详情请查看clickhouse-local的文档页面。

### 4. 更新和删除ClickHouse数据

尽管ClickHouse是面向高容量分析工作负载的，但在某些情况下可以修改或删除现有数据。这些操作被标记为“突变”，并使用ALTER TABLE命令执行。您还可以使用ClickHouse的轻量级删除功能删除一行。

**如果需要频繁更新，请考虑在ClickHouse中使用重复数据删除，这允许您在不生成突变事件的情况下更新和/或删除行。**

#### 更新数据

使用ALTER TABLE…UPDATE命令更新表中的行:

```
ALTER TABLE [<database>.]<table> UPDATE <column> = <expression> WHERE <filter_expr>
```

<expression>是满足<filter_expr>的列的新值。<表达式>必须与列的数据类型相同，或者可以使用CAST操作符转换为相同的数据类型。<filter_expr>应该为每一行数据返回UInt8(零或非零)值。多个UPDATE <column>语句可以组合在一个ALTER TABLE命令中，以逗号分隔。

例子:

1. 这样的突变允许使用字典查找更新替换visitor_ids:

```
ALTER TABLE website.clicks
UPDATE visitor_id = getDict('visitors', 'new_visitor_id', visitor_id)
WHERE visit_date < '2022-01-01'
```

2. 在一个命令中修改多个值比多个命令更有效:

```
ALTER TABLE website.clicks
UPDATE url = substring(url, position(url, '://') + 3), visitor_id = new_visit_id
WHERE visit_date < '2022-01-01'
```

3. 对于分片表，可以在CLUSTER上执行突变:

```
ALTER TABLE clicks ON CLUSTER main_cluster
UPDATE click_count = click_count / 2
WHERE visitor_id ILIKE '%robot%'
```

**不能更新作为主键或排序键一部分的列。**

#### 删除数据

使用ALTER TABLE命令删除行:

```
ALTER TABLE [<database>.]<table> DELETE WHERE <filter_expr>
```

<filter_expr>应该为每行数据返回UInt8值。

比如：
1. 删除列在值数组中的任何记录:

```
ALTER TABLE website.clicks DELETE WHERE visitor_id in (253, 1002, 4277)
```

2. 这个查询改变了什么?

```
ALTER TABLE clicks ON CLUSTER main_cluster WHERE visit_date < '2022-01-02 15:00:00' AND page_id = '573'
```

**要删除一个表中的所有数据，使用TRUNCATE table [<database]命令会更有效。] <表>命令。该命令也可以在CLUSTER上执行。**

#### 轻量级的删除

删除行的另一个选项是使用DELETE FROM命令，该命令被称为轻量级删除。删除的行被标记为立即删除，并将从所有后续查询中自动过滤掉，因此您不必等待部分合并或使用FINAL关键字。数据清理在后台异步进行。

```
DELETE FROM [db.]table [ON CLUSTER cluster] [WHERE expr]
```

例如，下面的查询将删除hits表中Title列中包含文本hello的所有行:

```
DELETE FROM hits WHERE Title LIKE '%hello%';
```

关于轻量级删除的一些注意事项:
* 此特性仅适用于MergeTree表引擎系列。
* 默认情况下，轻量级删除是异步的。将mutations_sync设置为1，等待一个副本处理语句，将mutations_sync设置为2，等待所有副本。
* 这个特性是实验性的，需要你设置allow_experimental_lightweight_delete为true:

```
SET allow_experimental_lightweight_delete = true;
```

### 5. 在ClickHouse中进行关联

ClickHouse完全支持JOIN，支持所有标准SQL JOIN类型。语法看起来应该很熟悉，你可以在JOIN上查看文档页面了解所有细节:

```
SELECT
*
FROM imdb.roles
JOIN imdb.actors_dictionary
ON imdb.roles.actor_id = imdb.actors_dictionary.id
```

ClickHouse还提供了对分析工作负载和时间序列分析有用的其他非标准SQL JOIN类型，包括ASOF连接。

ClickHouse有6种不同的连接执行算法，或者允许查询计划器在运行时根据资源可用性和使用情况自适应地选择和动态更改算法。

