### 轻量级的删除

```
DELETE FROM [db.]table [ON CLUSTER cluster] [WHERE expr]
```

DELETE FROM从表[db.]table 中删除行，匹配表达式expr。删除的行被标记为立即删除，并将自动从所有后续查询中过滤掉。数据清理在后台异步进行。此特性仅适用于MergeTree表引擎系列。

例如，下面的查询将删除hits表中Title列中包含文本hello的所有行:

```
DELETE FROM hits WHERE Title LIKE '%hello%';
```

默认情况下，轻量级删除是异步的。将mutations_sync设置为1，等待一个副本处理语句，将mutations_sync设置为2，等待所有副本。

**DELETE FROM需要ALTER DELETE权限:**

```
grant ALTER DELETE ON db.table to username;
```

#### 轻量级删除内部

轻量级删除背后的思想是，当一个Delete FROM表…ClickHouse只保存一个掩码，其中每一行被标记为“现有”或“已删除”。这些“被删除”的行对于后续查询将变得不可见，但在物理上，这些行仅在随后的合并中被删除。写这个掩码通常比写ALTER table DELETE要轻量级得多…查询

它是如何实现的

掩码被实现为一个隐藏的_row_exists系统列，该列为所有可见行存储True，为已删除行存储False。如果删除了部分中的某些行，则此列仅出现在部分中。换句话说，当列的所有值都等于True时，它不会被持久化。

#### 选择查询

当列出现时，SELECT…FROM表，其中条件查询在内部由_row_exists上的附加谓词扩展，并且变得类似于

```
    SELECT ... FROM table PREWHERE _row_exists WHERE condition
```

在执行时，将读取列_row_exists，以确定哪些行不可见，如果有许多已删除的行，则可以确定在读取其余列时可以完全跳过哪些颗粒。

#### DELETE查询

DELETE FROM表WHERE条件转换为ALTER表UPDATE _row_exists = 0 WHERE条件突变。在内部，这个突变分2步执行:

1. SELECT count() FROM表中每个部件的WHERE条件，以确定该部件是否受到影响。
2. 变异受影响的部分，并使硬链接的未受影响的部分。在Wide部件的情况下，修改一个部件实际上只写入_row_exists列，而只是硬链接所有其他列的文件。但是对于Compact部分，所有列都被重写，因为它们都存储在一个文件中。

因此，如果我们比较第一步中的轻量级删除和ALTER Delete，它们都做同样的事情，以确定哪些部分受到影响，但在第二步中ALTER Delete要做更多的工作，因为它为受影响的部分读取和重写所有列的文件。

通过描述的实现，现在我们可以看到什么会对'DELETE FROM'的执行时间产生负面影响:

* DELETE查询中的WHERE条件重
* 由其他突变填充的突变队列，因为一个表上的所有突变都是按顺序执行的
* 有大量数据部分的表
* 在Compact部件中有大量数据——在Compact部件中，所有列都存储在一个文件中。

### 事务(ACID)支持

在MergeTree家族的一个表的一个分区中插入到max_insert_block_size行是事务性的(ACID):

* Atomic: INSERT作为一个整体被成功或拒绝:如果确认发送到客户端，所有行INSERT;如果错误被发送到客户端，没有行插入。
* Consistent:如果INSERT成功，插入的所有行都不违反表约束;如果违反约束，则不插入任何行。
* 隔离的:并发客户端观察表的一致性快照——表的状态就像INSERT之前或成功INSERT之后一样;没有局部状态;
* 持久:在响应客户端之前，成功的INSERT被写入文件系统，在单个副本或多个副本上(由insert_quorum设置控制)，并且ClickHouse可以要求操作系统在存储介质上同步文件系统数据(由fsync_after_insert设置控制)。
* 如果表有很多分区，INSERT覆盖了很多分区，那么插入到每个分区都是事务性的;
* 如果涉及物化视图，则可以用一条语句插入多个表;
* 插入分布式表整体上不是事务性的，而插入每个分片都是事务性的;
* 另一个例子:insert into Buffer表既不是原子的、孤立的、一致的、持久的;
* 即使启用了async_insert，原子性也会被确保，但可以通过wait_for_async_insert设置关闭;
* Max_insert_block_size默认为1 000 000，可以根据需要进行调整;
* 如果客户端没有收到来自服务器的答案，客户端不知道事务是否成功，它可以重复事务，只使用一次插入属性;
* ClickHouse内部使用MVCC与快照隔离;
* 所有的ACID属性是有效的，即使在服务器kill / crash的情况下;
* 应该启用insert_quorum到不同的AZ或fsync，以确保在典型设置中持久插入;
* ACID术语中的“一致性”不包括分布式系统的语义，参见https://jepsen.io/consistency，由不同的设置控制(select_sequential_consistency)
* 此解释不包括一个新的事务特性，该特性允许在多个表、物化视图、多个select等上拥有完整的事务。


